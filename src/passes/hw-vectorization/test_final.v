// Generated by CIRCT 42e53322a
module simple_vectorization(	// test.cleaned.mlir:2:3
  input  [3:0] in,	// test.cleaned.mlir:2:38
  output [3:0] out	// test.cleaned.mlir:2:52
);

  assign out = in;	// test.cleaned.mlir:3:5
endmodule

module reverse_endianess_vectorization(	// test.cleaned.mlir:5:3
  input  [3:0] in,	// test.cleaned.mlir:5:49
  output [3:0] out	// test.cleaned.mlir:5:63
);

  assign out = {<<{in}};	// test.cleaned.mlir:6:10, :7:5
endmodule

module linear_and_reverse(	// test.cleaned.mlir:9:3
  input  [7:0] in,	// test.cleaned.mlir:9:36
  input  [3:0] in2,	// test.cleaned.mlir:9:49
  output [7:0] out,	// test.cleaned.mlir:9:64
  output [3:0] out2	// test.cleaned.mlir:9:78
);

  assign out = in;	// test.cleaned.mlir:11:5
  assign out2 = {<<{in2}};	// test.cleaned.mlir:10:10, :11:5
endmodule

module bit_mixing_vectorization(	// test.cleaned.mlir:13:3
  input  [3:0] in2,	// test.cleaned.mlir:13:42
  input  [7:0] in,	// test.cleaned.mlir:13:56
  output [3:0] out2,	// test.cleaned.mlir:13:70
  output [7:0] out	// test.cleaned.mlir:13:85
);

  assign out2 = {in2[0], in2[3:1]};	// test.cleaned.mlir:14:10, :15:10, :16:10, :23:5
  assign out = {in[7:6], in[4], in[5], in[0], in[3:1]};	// test.cleaned.mlir:17:10, :18:10, :19:10, :20:10, :21:10, :22:10, :23:5
endmodule

module test_mux(	// test.cleaned.mlir:25:3
  input  [3:0] a,	// test.cleaned.mlir:25:26
               b,	// test.cleaned.mlir:25:38
  input        sel,	// test.cleaned.mlir:25:50
  output [3:0] result	// test.cleaned.mlir:25:65
);

  wire [3:0] _GEN = {4{sel}};	// test.cleaned.mlir:27:10
  assign result = a & _GEN | b & ~_GEN;	// test.cleaned.mlir:27:10, :28:10, :29:10, :30:10, :31:10, :32:5
endmodule

module test_and_enable(	// test.cleaned.mlir:34:3
  input  [3:0] a,	// test.cleaned.mlir:34:33
  input        enable,	// test.cleaned.mlir:34:45
  output [3:0] o	// test.cleaned.mlir:34:63
);

  assign o = a & {4{enable}};	// test.cleaned.mlir:35:10, :36:10, :37:5
endmodule

module test_multiple_patterns(	// test.cleaned.mlir:39:3
  input  [3:0] a,	// test.cleaned.mlir:39:40
               b,	// test.cleaned.mlir:39:52
               c,	// test.cleaned.mlir:39:64
  output [3:0] out_xor,	// test.cleaned.mlir:39:77
               out_and	// test.cleaned.mlir:39:95
);

  assign out_xor = a ^ b;	// test.cleaned.mlir:40:10, :42:5
  assign out_and = a & c;	// test.cleaned.mlir:41:10, :42:5
endmodule

module test_multiple_patterns_reverse(	// test.cleaned.mlir:44:3
  input  [3:0] a,	// test.cleaned.mlir:44:48
               b,	// test.cleaned.mlir:44:60
  output [3:0] out_xor	// test.cleaned.mlir:44:73
);

  assign out_xor = {a[3] ^ b[0], a[2] ^ b[1], a[1] ^ b[2], a[0] ^ b[3]};	// test.cleaned.mlir:45:10, :46:10, :47:10, :48:10, :49:10, :50:10, :51:10, :52:10, :53:10, :54:10, :55:11, :56:11, :57:11, :58:5
endmodule

module CustomLogic(	// test.cleaned.mlir:60:3
  input  [7:0] a,	// test.cleaned.mlir:60:29
               b,	// test.cleaned.mlir:60:41
  output [7:0] out	// test.cleaned.mlir:60:54
);

  assign out = a & b | ~a;	// test.cleaned.mlir:62:10, :63:10, :64:10, :65:5
endmodule

module GatedXOR(	// test.cleaned.mlir:67:3
  input  [3:0] a,	// test.cleaned.mlir:67:26
               b,	// test.cleaned.mlir:67:38
  input        enable,	// test.cleaned.mlir:67:50
  output [3:0] out	// test.cleaned.mlir:67:68
);

  assign out = (a ^ b) & {4{enable}};	// test.cleaned.mlir:68:10, :69:10, :70:10, :71:5
endmodule

module with_logic_gate(	// test.cleaned.mlir:73:3
  input  [3:0] in,	// test.cleaned.mlir:73:33
  output [3:0] out	// test.cleaned.mlir:73:47
);

  assign out = {in[3:1], in[1] ^ in[0]};	// test.cleaned.mlir:74:10, :75:10, :76:10, :77:10, :78:10, :79:5
endmodule

module bit_drop(	// test.cleaned.mlir:81:3
  input  [3:0] in,	// test.cleaned.mlir:81:26
  output [3:0] out	// test.cleaned.mlir:81:40
);

  assign out = {in[3:1], 1'h0};	// test.cleaned.mlir:82:14, :83:10, :84:10, :85:5
endmodule

module bit_duplicate(	// test.cleaned.mlir:87:3
  input  [3:0] in,	// test.cleaned.mlir:87:31
  output [3:0] out	// test.cleaned.mlir:87:45
);

  assign out = {in[3:2], {2{in[0]}}};	// test.cleaned.mlir:88:10, :89:10, :90:10, :91:5
endmodule

module ShuffledXOR(	// test.cleaned.mlir:93:3
  input  [3:0] a,	// test.cleaned.mlir:93:29
               b,	// test.cleaned.mlir:93:41
  output [3:0] out	// test.cleaned.mlir:93:54
);

  wire [3:0] temp = a ^ b;	// test.cleaned.mlir:94:10
  assign out = {temp[0], temp[2], temp[3], temp[1]};	// test.cleaned.mlir:94:10, :95:10, :96:10, :97:10, :98:10, :99:10, :100:5
endmodule

module LogicalShiftRightBy2(	// test.cleaned.mlir:102:3
  input  [7:0] in,	// test.cleaned.mlir:102:38
  output [7:0] out	// test.cleaned.mlir:102:52
);

  assign out = {2'h0, in[7:2]};	// test.cleaned.mlir:103:14, :104:10, :105:10, :106:5
endmodule

module VectorizedEnable(	// test.cleaned.mlir:108:3
  input  [3:0] a,	// test.cleaned.mlir:108:34
               enable,	// test.cleaned.mlir:108:46
  output [3:0] o	// test.cleaned.mlir:108:64
);

  assign o = a & enable;	// test.cleaned.mlir:109:10, :110:5
endmodule

module mixed_sources(	// test.cleaned.mlir:112:3
  input  [3:0] in1,	// test.cleaned.mlir:112:31
               in2,	// test.cleaned.mlir:112:45
  output [7:0] out	// test.cleaned.mlir:112:60
);

  assign out = {in1, 4'h0} | {4'h0, in2};	// test.cleaned.mlir:113:14, :114:10, :115:10, :116:10, :117:5
endmodule

module InconsistentLogic(	// test.cleaned.mlir:119:3
  input  [3:0] a,	// test.cleaned.mlir:119:35
               b,	// test.cleaned.mlir:119:47
  output [3:0] out	// test.cleaned.mlir:119:60
);

  assign out = {a[3] & b[3], a[2] | b[2], a[1] ^ b[1], ~(a[0])};	// test.cleaned.mlir:121:10, :122:10, :123:10, :124:10, :125:10, :126:10, :127:10, :128:10, :129:10, :130:10, :131:11, :132:11, :133:5
endmodule

module ShiftAndXOR(	// test.cleaned.mlir:135:3
  input  [3:0] a,	// test.cleaned.mlir:135:29
               b,	// test.cleaned.mlir:135:41
  output [3:0] out	// test.cleaned.mlir:135:54
);

  assign out = {a[3] ^ b[2], a[2] ^ b[1], a[1] ^ b[0], a[0]};	// test.cleaned.mlir:136:10, :137:10, :138:10, :139:10, :140:10, :141:10, :142:10, :143:10, :144:10, :145:10, :146:11, :147:5
endmodule

module intermodule_vectorization(	// test.cleaned.mlir:149:3
  input  [3:0] in,	// test.cleaned.mlir:149:43
  output [3:0] out	// test.cleaned.mlir:149:57
);

  assign out = in;	// test.cleaned.mlir:150:5
endmodule

module top_byte_swap(	// test.cleaned.mlir:152:3
  input  [7:0] i,	// test.cleaned.mlir:152:31
  output [7:0] o	// test.cleaned.mlir:152:44
);

  assign o = {i[3:0], i[7:4]};	// test.cleaned.mlir:153:10, :154:10, :155:10, :156:5
endmodule

module CarryChainAdder(	// test.cleaned.mlir:158:3
  input  [3:0] a,	// test.cleaned.mlir:158:33
               b,	// test.cleaned.mlir:158:45
  output [3:0] sum	// test.cleaned.mlir:158:58
);

  wire       _GEN;	// test.cleaned.mlir:186:11
  wire       _GEN_0;	// test.cleaned.mlir:178:11
  wire       _GEN_1;	// test.cleaned.mlir:170:10
  wire [2:0] _GEN_2 = {_GEN, 2'h0} | {1'h0, {_GEN_0, 1'h0} | {1'h0, _GEN_1}};	// test.cleaned.mlir:159:14, :160:14, :161:10, :162:10, :163:10, :164:10, :165:10, :166:10, :170:10, :178:11, :186:11
  assign _GEN_1 = a[0] & b[0];	// test.cleaned.mlir:167:10, :168:10, :170:10
  assign _GEN_0 = a[1] & b[1] | a[1] & _GEN_2[0] | b[1] & _GEN_2[0];	// test.cleaned.mlir:166:10, :171:11, :172:11, :173:11, :175:11, :176:11, :177:11, :178:11
  assign _GEN = a[2] & b[2] | a[2] & _GEN_2[1] | b[2] & _GEN_2[1];	// test.cleaned.mlir:166:10, :179:11, :180:11, :181:11, :183:11, :184:11, :185:11, :186:11
  assign sum =
    {a[3] ^ b[3] ^ _GEN_2[2],
     a[2] ^ b[2] ^ _GEN_2[1],
     a[1] ^ b[1] ^ _GEN_2[0],
     a[0] ^ b[0]};	// test.cleaned.mlir:166:10, :167:10, :168:10, :169:10, :171:11, :172:11, :173:11, :174:11, :179:11, :180:11, :181:11, :182:11, :187:11, :188:11, :189:11, :190:11, :191:11, :192:5
endmodule

module test_add(	// test.cleaned.mlir:194:3
  input  [3:0] a,	// test.cleaned.mlir:194:26
               b,	// test.cleaned.mlir:194:38
  output [3:0] o	// test.cleaned.mlir:194:51
);

  wire _GEN;	// test.cleaned.mlir:218:11
  wire _GEN_0;	// test.cleaned.mlir:215:11
  wire _GEN_1;	// test.cleaned.mlir:212:11
  wire _GEN_2;	// test.cleaned.mlir:209:11
  assign _GEN_2 = a[3] + b[3];	// test.cleaned.mlir:207:10, :208:11, :209:11
  assign _GEN_1 = a[2] + b[2];	// test.cleaned.mlir:210:11, :211:11, :212:11
  assign _GEN_0 = a[1] + b[1];	// test.cleaned.mlir:213:11, :214:11, :215:11
  assign _GEN = a[0] + b[0];	// test.cleaned.mlir:216:11, :217:11, :218:11
  assign o =
    {_GEN_2, 3'h0} | {1'h0, {_GEN_1, 2'h0} | {1'h0, {_GEN_0, 1'h0} | {1'h0, _GEN}}};	// test.cleaned.mlir:195:14, :196:14, :197:14, :198:10, :199:10, :200:10, :201:10, :202:10, :203:10, :204:10, :205:10, :206:10, :209:11, :212:11, :215:11, :218:11, :219:5
endmodule

module VectorizedSubtraction(	// test.cleaned.mlir:221:3
  input  [7:0] a,	// test.cleaned.mlir:221:39
               b,	// test.cleaned.mlir:221:51
  output [7:0] o	// test.cleaned.mlir:221:64
);

  wire _GEN;	// test.cleaned.mlir:273:11
  wire _GEN_0;	// test.cleaned.mlir:270:11
  wire _GEN_1;	// test.cleaned.mlir:267:11
  wire _GEN_2;	// test.cleaned.mlir:264:11
  wire _GEN_3;	// test.cleaned.mlir:261:11
  wire _GEN_4;	// test.cleaned.mlir:258:11
  wire _GEN_5;	// test.cleaned.mlir:255:11
  wire _GEN_6;	// test.cleaned.mlir:252:11
  assign _GEN_6 = a[7] - b[7];	// test.cleaned.mlir:250:11, :251:11, :252:11
  assign _GEN_5 = a[6] - b[6];	// test.cleaned.mlir:253:11, :254:11, :255:11
  assign _GEN_4 = a[5] - b[5];	// test.cleaned.mlir:256:11, :257:11, :258:11
  assign _GEN_3 = a[4] - b[4];	// test.cleaned.mlir:259:11, :260:11, :261:11
  assign _GEN_2 = a[3] - b[3];	// test.cleaned.mlir:262:11, :263:11, :264:11
  assign _GEN_1 = a[2] - b[2];	// test.cleaned.mlir:265:11, :266:11, :267:11
  assign _GEN_0 = a[1] - b[1];	// test.cleaned.mlir:268:11, :269:11, :270:11
  assign _GEN = a[0] - b[0];	// test.cleaned.mlir:271:11, :272:11, :273:11
  assign o =
    {_GEN_6, 7'h0}
    | {1'h0,
       {_GEN_5, 6'h0}
         | {1'h0,
            {_GEN_4, 5'h0}
              | {1'h0,
                 {_GEN_3, 4'h0}
                   | {1'h0,
                      {_GEN_2, 3'h0}
                        | {1'h0,
                           {_GEN_1, 2'h0} | {1'h0, {_GEN_0, 1'h0} | {1'h0, _GEN}}}}}}};	// test.cleaned.mlir:222:14, :223:14, :224:14, :225:14, :226:14, :227:14, :228:14, :229:10, :230:10, :231:10, :232:10, :233:10, :234:10, :235:10, :236:10, :237:10, :238:10, :239:11, :240:11, :241:11, :242:11, :243:11, :244:11, :245:11, :246:11, :247:11, :248:11, :249:11, :252:11, :255:11, :258:11, :261:11, :264:11, :267:11, :270:11, :273:11, :274:5
endmodule

module raw_example(	// test.cleaned.mlir:276:3
  input  [3:0] in,	// test.cleaned.mlir:276:29
  output [3:0] out	// test.cleaned.mlir:276:43
);

  wire _in_3;	// test.cleaned.mlir:279:10
  assign _in_3 = in[3];	// test.cleaned.mlir:279:10
  assign out = {_in_3, _in_3 & in[2], in[1:0]};	// test.cleaned.mlir:277:10, :278:10, :279:10, :280:10, :281:10, :282:5
endmodule

module cross_dependency(	// test.cleaned.mlir:284:3
  input  [1:0] in,	// test.cleaned.mlir:284:34
  output [1:0] out	// test.cleaned.mlir:284:48
);

  wire _GEN;	// test.cleaned.mlir:288:10
  wire _GEN_0 = in[0] ^ _GEN;	// test.cleaned.mlir:285:10, :286:10, :288:10
  assign _GEN = in[1] ^ _GEN_0;	// test.cleaned.mlir:286:10, :287:10, :288:10
  assign out = {_GEN, _GEN_0};	// test.cleaned.mlir:286:10, :288:10, :289:10, :290:5
endmodule

